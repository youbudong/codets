package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/spf13/viper"
)

// 解析openapi的文件，生成ts的interface文件
// ```yaml
// APIFOX_PROJCET:
//   - id: 1
//     name: project1
//   - id: 2
//     name: project2
// APIFOX_TOKEN: xxx
// OUTPUT_DIR: types
// ```
// 读取apifox.yaml变量APIFOX_PROJCET列表 包含id和name
// 读取apifox.yaml变量APIFOX_TOKEN

// 迭代加载openapi文件，解析出ts的interface文件

type Project struct {
	Id   string
	Name string
}

type Projects []Project

func main() {

	// 加载yaml文件
	viper.SetConfigName("apifox")
	viper.AddConfigPath(".")
	viper.SetConfigType("yaml")
	err := viper.ReadInConfig()
	if err != nil {
		panic(err)
	}

	currDir, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	// 读取APIFOX_TOKEN
	token := viper.GetString("APIFOX_TOKEN")
	// 读取OUTPUT_DIR
	odir := viper.GetString("OUTPUT_DIR")
	// 读取APIFOX_PROJCET列表
	projects := Projects{}
	err = viper.UnmarshalKey("APIFOX_PROJCET", &projects)
	if err != nil {
		panic(err)
	}

	dir := filepath.Join(currDir, odir)
	// 确保目录存在
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		panic(err)
	}

	// 迭代加载openapi文件，解析出ts的interface文件
	// Do something with route.Operation
	for _, project := range projects {
		projectId := project.Id
		openApiData, err := loadOpenApi(projectId, token)
		if err != nil {
			panic(err)
		}

		// fmt.Printf("Load %s\n", string(openApiData))
		// 解析openapi文件
		loader := openapi3.NewLoader()
		doc, err := loader.LoadFromData(openApiData)
		if err != nil {
			panic(err)
		}
		// err = doc.Validate(loader.Context)
		// if err != nil {
		// 	panic(err)
		// }

		// 生成Components name typescript文件
		filename := fmt.Sprintf("/%s.ts", project.Name)
		filepath := filepath.Join(dir, filename)
		// 文件存在则覆盖 否则创建
		file, err := os.OpenFile(filepath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
		if err != nil {
			panic(err)
		}

		file.WriteString("/* Code generated by apifox-ts-interface. DO NOT EDIT. */\n\n")

		components := doc.Components
		for name, schema := range components.Schemas {
			_, err = file.WriteString(fmt.Sprintf("export interface %s {\n", name))
			if err != nil {
				panic(err)
			}
			for key, value := range schema.Value.Properties {

				valueTypes := []string{}

				for _, v := range value.Value.Type.Slice() {
					if v == "array" {
						// array类型需要判断items类型
						items := value.Value.Items
						if items.Ref != "" {
							atype := strings.Split(items.Ref, "/")[len(strings.Split(items.Ref, "/"))-1]
							file.WriteString(fmt.Sprintf("  %s: %s[];\n", key, atype))
						}

						continue
					}

					if v == "object" {
						// object类型需要判断properties类型
						if value.Ref != "" {
							atype := strings.Split(value.Ref, "/")[len(strings.Split(value.Ref, "/"))-1]
							file.WriteString(fmt.Sprintf("  %s: %s;\n", key, atype))
						}
						continue
					}

					valueTypes = append(valueTypes, openaiTypesMaperts[v])
				}

				valueTypesStr := strings.Join(valueTypes, " | ")

				if valueTypesStr != "" {
					description := value.Value.Description
					if description != "" {
						_, err = file.WriteString(fmt.Sprintf("  /** %s */\n", description))
						if err != nil {
							panic(err)
						}
					}
					_, err = file.WriteString(fmt.Sprintf("  %s: %s;\n", key, valueTypesStr))
					if err != nil {
						panic(err)
					}
				}
			}
			_, err = file.WriteString("}\n")
			if err != nil {
				panic(err)
			}
		}
		err = file.Close()
		if err != nil {
			panic(err)
		}
		fmt.Printf("Generate %s\n", filename)
	}
}

func loadOpenApi(projectId string, token string) ([]byte, error) {

	requestBody := map[string]interface{}{"scope": map[string]interface{}{"type": "ALL"}}
	jsonData, _ := json.Marshal(requestBody)
	req, err := http.NewRequest("POST", fmt.Sprintf("https://api.apifox.com/v1/projects/%s/export-openapi", projectId), bytes.NewBuffer(jsonData))
	if err != nil {
		panic(err)
	}
	req.Header.Set("X-Apifox-Api-Version", "2024-03-28")
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
	req.Header.Set("Content-Type", "application/json")
	// Perform the request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("error response code: %d", resp.StatusCode)
	}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return body, nil
}

var openaiTypesMaperts = map[string]string{
	"string":  "string",
	"number":  "number",
	"integer": "number",
	"boolean": "boolean",
	"array":   "Array",
	"object":  "object",
	"null":    "null",
	"any":     "any",
}
