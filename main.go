package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/spf13/viper"
)

// 解析openapi的文件，生成ts的interface文件
// ```yaml
// APIFOX_PROJCET:
//   - id: 1
//     name: project1
//   - id: 2
//     name: project2
// APIFOX_TOKEN: xxx
// OUTPUT_DIR: types
// ```
// 读取apifox.yaml变量APIFOX_PROJCET列表 包含id和name
// 读取apifox.yaml变量APIFOX_TOKEN

// 迭代加载openapi文件，解析出ts的interface文件

// 项目
type Project struct {
	Id   string
	Name string
	File string
}

// 项目列表
type Projects []Project

func main() {

	// 加载yaml文件
	viper.SetConfigName("apifox")
	viper.AddConfigPath(".")
	viper.SetConfigType("yaml")
	err := viper.ReadInConfig()
	if err != nil {
		panic(err)
	}

	currDir, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	// 读取APIFOX_TOKEN
	token := viper.GetString("APIFOX_TOKEN")
	// 读取OUTPUT_DIR
	odir := viper.GetString("OUTPUT_DIR")
	otype := viper.GetString("OUTPUT_TYPE")
	// 读取APIFOX_PROJCET列表
	projects := Projects{}
	err = viper.UnmarshalKey("APIFOX_PROJCET", &projects)
	if err != nil {
		panic(err)
	}

	dir := filepath.Join(currDir, odir)
	// 确保目录存在
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		panic(err)
	}

	// 迭代加载openapi文件，解析出ts的interface文件
	// Do something with route.Operation
	for _, project := range projects {

		// 准备生成文件
		fmt.Printf("Start generate id: %s, name: %s\n", project.Id, project.Name)

		projectId := project.Id
		var openApiData []byte
		if project.File != "" {
			// 读取指定文件
			dir := filepath.Join(currDir, project.File)
			openApiData, err = os.ReadFile(dir)
			if err != nil {
				panic(err)
			}
		} else {
			openApiData, err = loadOpenApi(projectId, token)
			if err != nil {
				panic(err)
			}
		}

		// fmt.Printf("Load %s\n", string(openApiData))
		// 解析openapi文件
		loader := openapi3.NewLoader()
		doc, err := loader.LoadFromData(openApiData)
		if err != nil {
			panic(err)
		}
		// 生成Components name typescript文件
		filename := fmt.Sprintf("/%s.%s", project.Name, otype)
		filepath := filepath.Join(dir, filename)
		// 文件存在则覆盖 否则创建
		file, err := os.OpenFile(filepath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
		if err != nil {
			panic(err)
		}

		file.WriteString("/* Code generated by codets-apifox. DO NOT EDIT. */\n\n")

		// schemas := doc.Components.Schemas
		switch otype {
		case "ts":
			fileTypescript(file, doc.Components.Schemas)
		case "go":
			fileGo(file, doc.Components.Schemas)
		default:
			if otype != "" {
				fmt.Printf("Unsupported output type: %s\n", otype)
				break
			}
			fileTypescript(file, doc.Components.Schemas)
		}

		err = file.Close()
		if err != nil {
			panic(err)
		}
		// 生成完成
		fmt.Printf("Generation completed %s\n\n", filename)
	}
}

var openaiTypesTSMaperts = map[string]string{
	"string":  "string",
	"number":  "number",
	"integer": "number",
	"boolean": "boolean",
	"array":   "Array",
	"object":  "object",
	"null":    "null",
	"any":     "any",
}

var openaiTypesGOMaperts = map[string]string{
	"string":  "string",
	"number":  "float64",
	"integer": "int64",
	"boolean": "bool",
	"array":   "[]",
	"object":  "struct",
	"null":    "interface{}",
	"any":     "interface{}",
}

// 首字母大写
func firstUpper(str string) string {
	if len(str) == 0 {
		return ""
	}
	return strings.ToUpper(str[0:1]) + str[1:]
}

func fileTypescript(file *os.File, schemas openapi3.Schemas) {

	// 顺序map
	sortMapSchemas(schemas, func(name string, schema *openapi3.SchemaRef) {
		_, err := file.WriteString(fmt.Sprintf("export interface %s {\n", name))
		if err != nil {
			panic(err)
		}
		sortMapSchemas(schema.Value.Properties, func(key string, value *openapi3.SchemaRef) {
			valueTypes := []string{}
			for _, v := range value.Value.Type.Slice() {
				if v == "array" {
					// array类型需要判断items类型
					items := value.Value.Items
					if items.Ref != "" {
						atype := strings.Split(items.Ref, "/")[len(strings.Split(items.Ref, "/"))-1]
						file.WriteString(fmt.Sprintf("  %s: %s[];\n", key, atype))
					}

					if items.Value.Type.Is("string") {
						file.WriteString(fmt.Sprintf("  %s: string[];\n", key))
					}
					continue
				}

				if v == "object" {
					// object类型需要判断properties类型
					if value.Ref != "" {
						atype := strings.Split(value.Ref, "/")[len(strings.Split(value.Ref, "/"))-1]
						file.WriteString(fmt.Sprintf("  %s: %s;\n", key, atype))
					}
					continue
				}

				valueTypes = append(valueTypes, openaiTypesTSMaperts[v])
			}

			valueTypesStr := strings.Join(valueTypes, " | ")

			if valueTypesStr != "" {
				description := value.Value.Description
				if description != "" {
					_, err = file.WriteString(fmt.Sprintf("  /** %s */\n", description))
					if err != nil {
						panic(err)
					}
				}
				_, err = file.WriteString(fmt.Sprintf("  %s: %s;\n", key, valueTypesStr))
				if err != nil {
					panic(err)
				}
			}
		})

		_, err = file.WriteString("}\n")
		if err != nil {
			panic(err)
		}
	})

}

func fileGo(file *os.File, schemas openapi3.Schemas) {

	file.WriteString(fmt.Sprintf("package %s \n", "types"))

	for name, schema := range schemas {
		_, err := file.WriteString(fmt.Sprintf("type %s struct {\n", name))
		if err != nil {
			panic(err)
		}
		for key, value := range schema.Value.Properties {

			valueTypes := []string{}

			for _, v := range value.Value.Type.Slice() {
				if v == "array" {
					// array类型需要判断items类型
					items := value.Value.Items
					if items.Ref != "" {
						atype := strings.Split(items.Ref, "/")[len(strings.Split(items.Ref, "/"))-1]
						file.WriteString(fmt.Sprintf("  %s []%s `json:\"%s\"`\n", firstUpper(key), atype, key))
					}

					if items.Value.Type.Is("string") {
						file.WriteString(fmt.Sprintf("  %s []string `json:\"%s\"`\n", firstUpper(key), key))
					}
					continue
				}

				if v == "object" {
					// object类型需要判断properties类型
					if value.Ref != "" {
						atype := strings.Split(value.Ref, "/")[len(strings.Split(value.Ref, "/"))-1]
						file.WriteString(fmt.Sprintf("  %s %s `json:\"%s\"`\n", firstUpper(key), atype, key))
					}
					continue
				}

				valueTypes = append(valueTypes, openaiTypesGOMaperts[v])
			}

			// valueTypesStr := strings.Join(valueTypes, " ")
			// 如果有多个类型，则只取第一个类型
			valueTypesStr := ""
			if len(valueTypes) > 0 {
				valueTypesStr = valueTypes[0]
			}

			if valueTypesStr != "" {
				description := value.Value.Description
				if description != "" {
					_, err = file.WriteString(fmt.Sprintf("  // %s\n", description))
					if err != nil {
						panic(err)
					}
				}
				_, err = file.WriteString(fmt.Sprintf("  %s %s `json:\"%s\"`\n", firstUpper(key), valueTypesStr, key))
				if err != nil {
					panic(err)
				}
			}
		}
		_, err = file.WriteString("}\n")
		if err != nil {
			panic(err)
		}
	}
}

// sortMapKeys 接受一个 map 和一个函数，该函数用于处理排序后键值对。
func sortMapSchemas(m openapi3.Schemas, handler func(k string, v *openapi3.SchemaRef)) {
	// 提取 map 的键到一个切片
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}

	// 对键进行排序
	sort.Strings(keys)

	// 通过排序后的键迭代 map，并调用处理函数
	for _, k := range keys {
		handler(k, m[k])
	}
}
