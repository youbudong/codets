package main

import (
	"fmt"
	"slices"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

func fileTypescript(odir, projectName string, schemas openapi3.Schemas) {
	filename := fmt.Sprintf("%s.%s", projectName, "d.ts")
	file := GetOsFile(odir, filename)
	defer file.Close()

	file.WriteString("// Code generated by codets-apifox. DO NOT EDIT.\n\n")

	// 顺序map
	sortMapSchemas(schemas, func(name string, schema *openapi3.SchemaRef) {
		_, err := file.WriteString(fmt.Sprintf("export interface %s {\n", name))
		if err != nil {
			panic(err)
		}
		sortMapSchemas(schema.Value.Properties, func(key string, value *openapi3.SchemaRef) {
			valueTypes := []string{}
			for _, v := range value.Value.Type.Slice() {
				if v == "array" {
					// array类型需要判断items类型
					items := value.Value.Items
					if items.Ref != "" {
						atype := strings.Split(items.Ref, "/")[len(strings.Split(items.Ref, "/"))-1]
						// file.WriteString(fmt.Sprintf("  %s: %s[];\n", key, atype))
						required := slices.Contains(schema.Value.Required, key)
						if required {
							file.WriteString(fmt.Sprintf("  %s: %s[];\n", key, atype))
						} else {
							file.WriteString(fmt.Sprintf("  %s?: %s[];\n", key, atype))
						}
					}

					if items.Value.Type.Is("string") {
						// file.WriteString(fmt.Sprintf("  %s: string[];\n", key))
						required := slices.Contains(schema.Value.Required, key)
						if required {
							file.WriteString(fmt.Sprintf("  %s: string[];\n", key))
						} else {
							file.WriteString(fmt.Sprintf("  %s?: string[];\n", key))
						}
					}
					continue
				}

				if v == "object" {
					// object类型需要判断properties类型
					if value.Ref != "" {
						atype := strings.Split(value.Ref, "/")[len(strings.Split(value.Ref, "/"))-1]
						// file.WriteString(fmt.Sprintf("  %s: %s;\n", key, atype))
						required := slices.Contains(schema.Value.Required, key)
						if required {
							file.WriteString(fmt.Sprintf("  %s: %s;\n", key, atype))
						} else {
							file.WriteString(fmt.Sprintf("  %s?: %s;\n", key, atype))
						}
					}
					continue
				}

				valueTypes = append(valueTypes, openaiTypesTSMaperts[v])
			}

			valueTypesStr := strings.Join(valueTypes, " | ")

			if valueTypesStr != "" {
				description := value.Value.Description
				if description != "" {
					_, err = file.WriteString(fmt.Sprintf("  /** %s */\n", description))
					if err != nil {
						panic(err)
					}
				}
				// _, err = file.WriteString(fmt.Sprintf("  %s: %s;\n", key, valueTypesStr))
				required := slices.Contains(schema.Value.Required, key)
				if required {
					_, err = file.WriteString(fmt.Sprintf("  %s: %s;\n", key, valueTypesStr))
				} else {
					_, err = file.WriteString(fmt.Sprintf("  %s?: %s;\n", key, valueTypesStr))
				}
				if err != nil {
					panic(err)
				}
			}
		})

		_, err = file.WriteString("}\n")
		if err != nil {
			panic(err)
		}
	})

}

func fileTsClient(dir, projectName string, doc *openapi3.T) {
	// 生成js的client文件
	// 读取openapi的paths
	filename := fmt.Sprintf("%s.%s", projectName, "ts")

	file := GetOsFile(dir, filename)
	defer file.Close()
	file.WriteString("// Code generated by codets-apifox. DO NOT EDIT.\n\n")

	file.WriteString("import { ClientAPIProps, createRequest } from '../request';\n\n")
	file.WriteString(fmt.Sprintf("export const create%sClientAPI = (props:ClientAPIProps) => {\n", firstUpper(strings.Replace(projectName, "Server", "", -1))))
	file.WriteString("  const { get, post } = createRequest(props);\n\n")

	// 遍历paths，生成js的client文件
	for path, pathItem := range doc.Paths.Map() {
		for method, operation := range pathItem.Operations() {
			ojson, _ := operation.MarshalJSON()
			fmt.Printf("operation: %v\n", strings.TrimSpace(string(ojson)))

			file.WriteString(fmt.Sprintf("  /** %s */\n", operation.Summary))
			funcName := GetFuncName(path)
			// fmt.Printf("%s, %s\n", funcName, method)

			if method == "POST" {
				file.WriteString(fmt.Sprintf("export const %s = async (data:%s) => {\n", funcName, strings.ReplaceAll(operation.RequestBody.Ref, "#/components/schemas/", "")))
			}

			// file.WriteString(fmt.Sprintf("export const %s = async (data) => {\n", funcName))

			// if operation.Parameters != nil {
			// 	pathkeys := []string{}
			// 	for _, param := range operation.Parameters {
			// 		if param.Value.In == "path" {
			// 			pathkeys = append(pathkeys, param.Value.Name)
			// 		}
			// 	}
			// 	if len(pathkeys) > 0 {
			// 		file.WriteString(fmt.Sprintf("  const { %s } = data;\n", strings.Join(pathkeys, ", ")))
			// 	}
			// }

			// stPath := strings.ReplaceAll(path, "{", "${")
			// file.WriteString(fmt.Sprintf("  const res = await request(`%s`, {\n", stPath))
			// file.WriteString(fmt.Sprintf("    method: '%s',\n", method))

			if operation.RequestBody != nil {
				// file.WriteString(fmt.Sprintf("    headers: {\n"))
				// file.WriteString(fmt.Sprintf("      'Content-Type': 'application/json',\n"))
				// // file.WriteString(fmt.Sprintf("      'Authorization': `Bearer ${token}`,\n"))
				// file.WriteString(fmt.Sprintf("    },\n"))
				// file.WriteString(fmt.Sprintf("    body: JSON.stringify(data),\n"))
			}
			// file.WriteString(fmt.Sprintf("  })\n"))
			// file.WriteString(fmt.Sprintf("  return res.json()\n"))
			// file.WriteString(fmt.Sprintf("}\n\n"))
		}
	}
	file.WriteString(fmt.Sprintf("}\n\n"))
}

func fileTsRequest(dir string) {
	// 生成js的request文件
	// 读取openapi的paths
	// 遍历paths，生成js的client文件
	file := GetOsFile(dir, "request.ts")
	defer file.Close()

	file.WriteString("// Code generated by codets-apifox. DO NOT EDIT.\n\n")
	file.WriteString(`export interface ClientAPIProps {
	baseURL: string;
	headers?: Record<string, string>;
	/** 单位 s */
	timeout?: number;
}

interface ResponseData<T> {
	code: number;
	msg: string;
	data: T;
}

export const createRequest = (props: ClientAPIProps) => {
	const { baseURL, headers, timeout } = props;

	const request = async <T>(url: string, options: RequestInit) => {
		const abortController = new AbortController();
		const signal = abortController.signal;
		const timeoutId = timeout
			? setTimeout(() => {
					abortController.abort();
				}, timeout)
			: null;
		const response = await fetch(` + "`${baseURL}${url}`" + `, {
			...options,
			headers: {
				...headers,
				"Content-Type": "application/json",
				...options.headers,
			},
			signal,
		});
		if (timeoutId) clearTimeout(timeoutId);
		if (!response.ok) {
			throw new Error(` + "`HTTP error! status: ${response.status}`" + `);
		}
		return (await response.json()) as ResponseData<T>;
	};

	return {
		get: async <T>(url: string, options?: RequestInit) => {
			return await request<T>(url, { method: "GET", ...options });
		},
		post: async <T>(url: string, body: any, options?: RequestInit) => {
			return await request<T>(url, {
				method: "POST",
				body: JSON.stringify(body),
				...options,
			});
		},
	};
};`)
}
