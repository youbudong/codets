package main

import (
	"fmt"
	"slices"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

func fileTypescript(odir, projectName string, schemas openapi3.Schemas) {
	filename := fmt.Sprintf("%s.%s", projectName, "ts")
	file := GetOsFile(odir, filename)
	defer file.Close()

	file.WriteString("// Code generated by codets-apifox. DO NOT EDIT.\n\n")

	// 顺序map
	sortMapSchemas(schemas, func(name string, schema *openapi3.SchemaRef) {
		_, err := file.WriteString(fmt.Sprintf("export interface %s {\n", name))
		if err != nil {
			panic(err)
		}
		sortMapSchemas(schema.Value.Properties, func(key string, value *openapi3.SchemaRef) {
			valueTypes := []string{}
			for _, v := range value.Value.Type.Slice() {
				description := value.Value.Description
				if description != "" {
					_, err = file.WriteString(fmt.Sprintf("  /** %s */\n", description))
					if err != nil {
						panic(err)
					}
				}
				if v == "array" {
					// array类型需要判断items类型
					items := value.Value.Items
					if items.Ref != "" {
						atype := strings.Split(items.Ref, "/")[len(strings.Split(items.Ref, "/"))-1]
						// file.WriteString(fmt.Sprintf("  %s: %s[];\n", key, atype))
						required := slices.Contains(schema.Value.Required, key)
						if required {
							file.WriteString(fmt.Sprintf("  %s: %s[];\n", key, atype))
						} else {
							file.WriteString(fmt.Sprintf("  %s?: %s[];\n", key, atype))
						}
					}

					if items.Value.Type.Is("string") {
						// file.WriteString(fmt.Sprintf("  %s: string[];\n", key))
						required := slices.Contains(schema.Value.Required, key)
						if required {
							file.WriteString(fmt.Sprintf("  %s: string[];\n", key))
						} else {
							file.WriteString(fmt.Sprintf("  %s?: string[];\n", key))
						}
					}
					if items.Value.Type.Is("integer") {
						required := slices.Contains(schema.Value.Required, key)
						if required {
							file.WriteString(fmt.Sprintf("  %s: number[];\n", key))
						} else {
							file.WriteString(fmt.Sprintf("  %s?: number[];\n", key))
						}
					}
					continue
				}

				if v == "object" {
					// object类型需要判断properties类型
					if value.Ref != "" {
						atype := strings.Split(value.Ref, "/")[len(strings.Split(value.Ref, "/"))-1]
						// file.WriteString(fmt.Sprintf("  %s: %s;\n", key, atype))
						required := slices.Contains(schema.Value.Required, key)
						if required {
							file.WriteString(fmt.Sprintf("  %s: %s;\n", key, atype))
						} else {
							file.WriteString(fmt.Sprintf("  %s?: %s;\n", key, atype))
						}
					}
					continue
				}

				valueTypes = append(valueTypes, openaiTypesTSMaperts[v])
			}

			valueTypesStr := strings.Join(valueTypes, " | ")

			if valueTypesStr != "" {

				// _, err = file.WriteString(fmt.Sprintf("  %s: %s;\n", key, valueTypesStr))
				required := slices.Contains(schema.Value.Required, key)
				if required {
					_, err = file.WriteString(fmt.Sprintf("  %s: %s;\n", key, valueTypesStr))
				} else {
					_, err = file.WriteString(fmt.Sprintf("  %s?: %s;\n", key, valueTypesStr))
				}
				if err != nil {
					panic(err)
				}
			}
		})

		_, err = file.WriteString("}\n\n")
		if err != nil {
			panic(err)
		}
	})

}

func fileTsClient(dir, projectName string, doc *openapi3.T) {
	// 生成js的client文件
	// 读取openapi的paths
	filename := fmt.Sprintf("%s.%s", projectName, "ts")

	file := GetOsFile(dir, filename)
	defer file.Close()
	file.WriteString("// Code generated by codets-apifox. DO NOT EDIT.\n\n")

	file.WriteString("import { ClientAPIProps, createRequest } from '../request';\n\n")
	file.WriteString(fmt.Sprintf("export const create%sClientAPI = (props:ClientAPIProps) => {\n", firstUpper(strings.Replace(projectName, "Server", "", -1))))
	file.WriteString("  const { get, post } = createRequest(props);\n\n")

	// 遍历paths，生成js的client文件
	refnames := []string{}
	funcnames := []string{}
	for path, pathItem := range doc.Paths.Map() {
		for method, operation := range pathItem.Operations() {
			// ojson, _ := operation.MarshalJSON()
			// fmt.Printf("operation: %v\n", strings.TrimSpace(string(ojson)))

			// body 参数
			refname := ""
			if operation.RequestBody != nil && operation.RequestBody.Value != nil && operation.RequestBody.Value.Content != nil && operation.RequestBody.Value.Content.Get("application/json") != nil {
				// fmt.Printf("%s\n", operation.RequestBody.Value.Content.Get("application/json").Schema.Ref)
				// ojson1, _ := operation.RequestBody.Value.MarshalJSON()
				// fmt.Printf("%v\n", strings.TrimSpace(string(ojson1)))
				refname = operation.RequestBody.Value.Content.Get("application/json").Schema.Ref
				refname = strings.ReplaceAll(refname, "#/components/schemas/", "")
				refnames = append(refnames, refname)
			}

			// query 参数
			querykeys := []string{}
			if operation.Parameters != nil {
				// fmt.Printf("operation: %v\n", strings.TrimSpace(string(ojson)))
				for _, param := range operation.Parameters {
					if param.Value.In == "query" {
						// ptype := param.Value.Schema.Value.Type.Slice()[0]
						// querykeys = append(querykeys, fmt.Sprintf("%s: %s", param.Value.Name, ptype))
						querykeys = append(querykeys, param.Value.Name)
					}
				}
			}
			fmt.Printf("querykeys: %v\n", querykeys)

			// 注释
			file.WriteString(fmt.Sprintf("  /** %s */\n", operation.Summary))
			// 处理第一行，包含函数名和body/path/query参数
			funcName := GetFuncName(path)
			funcnames = append(funcnames, funcName)
			funcNameAndParams := fmt.Sprintf("  const %s = async (", funcName)
			// path 参数
			paths := []string{}
			for _, param := range operation.Parameters {
				if param.Value.In == "path" {
					ptype := param.Value.Schema.Value.Type.Slice()[0]
					paths = append(paths, fmt.Sprintf("%s: %s", param.Value.Name, ptype))
				}
			}
			pathStr := ""
			if len(paths) > 0 {
				pathStr = fmt.Sprintf("{%s}", strings.Join(paths, ", "))
			}
			// 确定参数类型
			dataType := ""
			// body
			if refname != "" {
				dataType = refname
			}
			// query
			if len(querykeys) > 0 {
				if dataType != "" {
					dataType = fmt.Sprintf("%s &", dataType)
				}
				dataType = fmt.Sprintf("%s {%s}", dataType, strings.Join(querykeys, ", "))
			}
			// path
			if pathStr != "" {
				if dataType != "" {
					dataType = fmt.Sprintf("%s &", dataType)
				}
				dataType = fmt.Sprintf("%s %s", dataType, pathStr)
			}
			// data := (body/query)+ pathStr
			funcNameAndParams = fmt.Sprintf("%s data: %s) => {\n", funcNameAndParams, dataType)
			file.WriteString(funcNameAndParams)

			// 暂时
			file.WriteString("  }\n\n")

			// fmt.Printf("%s, %s\n", funcName, method)
			path := strings.ReplaceAll(path, "{", "${")
			fmt.Printf("%s, %s\n", method, path)

			// if method == "POST" {
			// 	if refname != "" {
			// 		file.WriteString(fmt.Sprintf("const { id } = data;\n"))
			// 		file.WriteString(fmt.Sprintf("  return await post(`%s`, data);\n", path))
			// 	} else {
			// 		file.WriteString(fmt.Sprintf("const %s = async () => {\n", funcName))
			// 		file.WriteString(fmt.Sprintf("  return await post(`%s`);\n", path))
			// 	}
			// 	file.WriteString("}\n\n")
			// } else {
			// 	file.WriteString(fmt.Sprintf("const %s = async () => {}\n", funcName))
			// }

			// file.WriteString(fmt.Sprintf("export const %s = async (data) => {\n", funcName))

			// if operation.Parameters != nil {
			// 	pathkeys := []string{}
			// 	for _, param := range operation.Parameters {
			// 		if param.Value.In == "path" {
			// 			pathkeys = append(pathkeys, param.Value.Name)
			// 		}
			// 	}
			// 	if len(pathkeys) > 0 {
			// 		file.WriteString(fmt.Sprintf("  const { %s } = data;\n", strings.Join(pathkeys, ", ")))
			// 	}
			// }

			// stPath := strings.ReplaceAll(path, "{", "${")
			// file.WriteString(fmt.Sprintf("  const res = await request(`%s`, {\n", stPath))
			// file.WriteString(fmt.Sprintf("    method: '%s',\n", method))

			if operation.RequestBody != nil {
				// file.WriteString(fmt.Sprintf("    headers: {\n"))
				// file.WriteString(fmt.Sprintf("      'Content-Type': 'application/json',\n"))
				// // file.WriteString(fmt.Sprintf("      'Authorization': `Bearer ${token}`,\n"))
				// file.WriteString(fmt.Sprintf("    },\n"))
				// file.WriteString(fmt.Sprintf("    body: JSON.stringify(data),\n"))
			}
			// file.WriteString(fmt.Sprintf("  })\n"))
			// file.WriteString(fmt.Sprintf("  return res.json()\n"))
			// file.WriteString(fmt.Sprintf("}\n\n"))
		}
	}
	file.WriteString("  return {" + strings.Join(funcnames, ", ") + "};\n")
	file.WriteString(fmt.Sprintf("}\n\n"))
	file.WriteString("import { " + strings.Join(RemoveDuplicates(refnames), ", ") + " } from '../types/" + projectName + "';\n")
}

func fileTsRequest(dir string) {
	// 生成js的request文件
	// 读取openapi的paths
	// 遍历paths，生成js的client文件
	file := GetOsFile(dir, "request.ts")
	defer file.Close()

	file.WriteString("// Code generated by codets-apifox. DO NOT EDIT.\n\n")
	file.WriteString(`export interface ClientAPIProps {
	baseURL: string;
	headers?: Record<string, string>;
	/** 单位 s */
	timeout?: number;
}

interface ResponseData<T> {
	code: number;
	msg: string;
	data: T;
}

export const createRequest = (props: ClientAPIProps) => {
	const { baseURL, headers, timeout } = props;

	const request = async <T>(url: string, options: RequestInit) => {
		const abortController = new AbortController();
		const signal = abortController.signal;
		const timeoutId = timeout
			? setTimeout(() => {
					abortController.abort();
				}, timeout)
			: null;
		const response = await fetch(` + "`${baseURL}${url}`" + `, {
			...options,
			headers: {
				...headers,
				"Content-Type": "application/json",
				...options.headers,
			},
			signal,
		});
		if (timeoutId) clearTimeout(timeoutId);
		if (!response.ok) {
			throw new Error(` + "`HTTP error! status: ${response.status}`" + `);
		}
		return (await response.json()) as ResponseData<T>;
	};

	return {
		get: async <T>(url: string, options?: RequestInit) => {
			return await request<T>(url, { method: "GET", ...options });
		},
		post: async <T>(url: string, body?: any, options?: RequestInit) => {
			return await request<T>(url, {
				method: "POST",
				body: JSON.stringify(body),
				...options,
			});
		},
	};
};`)
}

func RemoveDuplicates(input []string) []string {
	seen := make(map[string]struct{})
	result := make([]string, 0, len(input))

	for _, str := range input {
		if _, ok := seen[str]; !ok {
			seen[str] = struct{}{}
			result = append(result, str)
		}
	}

	return result
}
